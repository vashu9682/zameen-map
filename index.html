<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Land Area Measurement</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #f0f0f0;
            touch-action: none;
        }
        
        #map {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .point {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: red;
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-8px, -8px);
            cursor: pointer;
            z-index: 10;
        }
        
        .line {
            position: absolute;
            background-color: rgba(0, 100, 255, 0.7);
            height: 3px;
            transform-origin: 0 0;
            z-index: 5;
        }
        
        .distance-label {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            transform: translate(-50%, -50%);
            border: 1px solid #ccc;
            z-index: 15;
        }
        
        #controls {
            padding: 10px;
            background-color: #e0e0e0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        #results {
            padding: 15px;
            background-color: #f8f8f8;
            font-size: 16px;
        }
        
        #instructions {
            padding: 15px;
            background-color: #e8f4f8;
            font-size: 14px;
        }
        
        .area-fill {
            position: absolute;
            background-color: rgba(100, 200, 100, 0.3);
            z-index: 1;
        }
        
        @media (max-width: 600px) {
            button {
                padding: 12px 15px;
                flex: 1 0 40%;
            }
            
            #controls {
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Universal Land Measurement Tool</h2>
        <p>1. <strong>Tap anywhere</strong> to start measuring your land.</p>
        <p>2. Walk around your land and tap <strong>"Add Point"</strong> at each corner.</p>
        <p>3. For complex shapes: Mark all outer boundaries and any inner boundaries.</p>
        <p>4. <strong>"Complete Measurement"</strong> to close the shape or <strong>"Calculate Area"</strong> to finish.</p>
    </div>
    
    <div id="map-container">
        <div id="map"></div>
    </div>
    
    <div id="controls">
        <button id="add-point">Add Point</button>
        <button id="undo">Undo</button>
        <button id="complete" disabled>Complete Shape</button>
        <button id="calculate" disabled>Calculate Area</button>
        <button id="reset">Reset</button>
    </div>
    
    <div id="results">
        <p><strong>Total Area:</strong> <span id="area">0</span> square meters</p>
        <p><strong>Perimeter:</strong> <span id="perimeter">0</span> meters</p>
        <p><strong>Shape Type:</strong> <span id="shape-type">Not determined</span></p>
    </div>

    <script>
        const map = document.getElementById('map');
        const addPointBtn = document.getElementById('add-point');
        const undoBtn = document.getElementById('undo');
        const completeBtn = document.getElementById('complete');
        const calculateBtn = document.getElementById('calculate');
        const resetBtn = document.getElementById('reset');
        const areaDisplay = document.getElementById('area');
        const perimeterDisplay = document.getElementById('perimeter');
        const shapeTypeDisplay = document.getElementById('shape-type');
        
        let points = [];
        let lines = [];
        let distanceLabels = [];
        let areaFills = [];
        let isMeasuring = false;
        let firstPoint = null;
        
        // Initialize the map with click event
        map.addEventListener('click', (e) => {
            if (!isMeasuring) {
                startMeasurement(e);
            }
        });
        
        // Touch support for mobile devices
        map.addEventListener('touchstart', (e) => {
            if (!isMeasuring) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('click', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                map.dispatchEvent(mouseEvent);
            }
        }, { passive: false });
        
        addPointBtn.addEventListener('click', addPoint);
        undoBtn.addEventListener('click', undoLastPoint);
        completeBtn.addEventListener('click', completeMeasurement);
        calculateBtn.addEventListener('click', calculateArea);
        resetBtn.addEventListener('click', resetMeasurement);
        
        function startMeasurement(e) {
            isMeasuring = true;
            addPointBtn.disabled = false;
            undoBtn.disabled = false;
            
            // Create first point at clicked position
            const point = createPoint(e.clientX, e.clientY);
            points.push(point);
            firstPoint = point;
            
            // Update UI
            addPointBtn.textContent = "Add Next Point";
            shapeTypeDisplay.textContent = "Measuring...";
        }
        
        function addPoint() {
            if (!isMeasuring || points.length === 0) return;
            
            // For demonstration, we'll add points in a circular pattern
            // In a real app, this would use GPS or user taps on actual positions
            
            const lastPoint = points[points.length - 1];
            const rect = lastPoint.getBoundingClientRect();
            const lastX = rect.left + rect.width/2;
            const lastY = rect.top + rect.height/2;
            
            // Calculate angle based on number of points (creates a star pattern for demo)
            const angle = (points.length * 2.5) % (2 * Math.PI);
            const distance = 80 + (points.length % 3) * 40;
            
            const newX = lastX + Math.cos(angle) * distance;
            const newY = lastY + Math.sin(angle) * distance;
            
            const point = createPoint(newX, newY);
            points.push(point);
            
            // Draw line from last point to this one
            drawLine(points[points.length - 2], point);
            
            // Enable buttons after enough points
            if (points.length >= 2) {
                completeBtn.disabled = false;
                calculateBtn.disabled = false;
            }
            
            updateShapeType();
        }
        
        function undoLastPoint() {
            if (points.length <= 1) return;
            
            // Remove last point
            const lastPoint = points.pop();
            lastPoint.remove();
            
            // Remove last line if exists
            if (lines.length > 0) {
                const lastLine = lines.pop();
                lastLine.remove();
            }
            
            // Remove last distance label if exists
            if (distanceLabels.length > 0) {
                const lastLabel = distanceLabels.pop();
                lastLabel.remove();
            }
            
            // Remove area fill if exists
            clearAreaFills();
            
            // Update button states
            if (points.length < 2) {
                completeBtn.disabled = true;
                calculateBtn.disabled = true;
            }
            
            updateShapeType();
        }
        
        function completeMeasurement() {
            if (points.length < 3) return;
            
            // Connect last point to first point
            drawLine(points[points.length - 1], firstPoint);
            
            // Calculate the area
            calculateArea();
            
            // Disable buttons
            addPointBtn.disabled = true;
            completeBtn.disabled = true;
        }
        
        function calculateArea() {
            if (points.length < 3) return;
            
            // Convert points to coordinates
            const coordinates = points.map(point => {
                const rect = point.getBoundingClientRect();
                return {
                    x: rect.left + rect.width/2,
                    y: rect.top + rect.height/2
                };
            });
            
            // Calculate area using shoelace formula (works for all polygon types)
            let area = 0;
            let perimeter = 0;
            
            for (let i = 0; i < coordinates.length; i++) {
                const j = (i + 1) % coordinates.length;
                const xi = coordinates[i].x;
                const yi = coordinates[i].y;
                const xj = coordinates[j].x;
                const yj = coordinates[j].y;
                
                area += xi * yj - xj * yi;
                
                // Calculate perimeter
                const dx = xj - xi;
                const dy = yj - yi;
                perimeter += Math.sqrt(dx*dx + dy*dy);
            }
            
            area = Math.abs(area / 2);
            
            // Convert pixels to meters (simplified - in real app use scale or GPS)
            // Assuming 100px = 1m for demonstration
            const scaleFactor = 1/100;
            const areaInMeters = (area * scaleFactor * scaleFactor).toFixed(2);
            const perimeterInMeters = (perimeter * scaleFactor).toFixed(2);
            
            areaDisplay.textContent = areaInMeters;
            perimeterDisplay.textContent = perimeterInMeters;
            
            // Disable buttons
            addPointBtn.disabled = true;
            completeBtn.disabled = true;
            calculateBtn.disabled = true;
            
            // Fill the area for visualization
            fillArea(coordinates);
            
            updateShapeType();
        }
        
        function fillArea(coordinates) {
            clearAreaFills();
            
            // Create SVG polygon to fill the area
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.zIndex = '1';
            
            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute("fill", "rgba(100, 200, 100, 0.3)");
            polygon.setAttribute("stroke", "rgba(0, 100, 255, 0.5)");
            polygon.setAttribute("stroke-width", "2");
            
            let pointsStr = '';
            for (const coord of coordinates) {
                pointsStr += `${coord.x},${coord.y} `;
            }
            polygon.setAttribute("points", pointsStr.trim());
            
            svg.appendChild(polygon);
            map.appendChild(svg);
            areaFills.push(svg);
        }
        
        function clearAreaFills() {
            areaFills.forEach(fill => fill.remove());
            areaFills = [];
        }
        
        function updateShapeType() {
            if (points.length < 3) {
                shapeTypeDisplay.textContent = "Not enough points";
                return;
            }
            
            // Simple shape detection (for demonstration)
            if (points.length === 3) {
                shapeTypeDisplay.textContent = "Triangle";
            } else if (points.length === 4) {
                // Check if quadrilateral is convex
                shapeTypeDisplay.textContent = "Quadrilateral (Convex)";
            } else if (points.length > 4) {
                // For complex shapes
                shapeTypeDisplay.textContent = "Complex Polygon";
            }
        }
        
        function resetMeasurement() {
            // Remove all elements
            points.forEach(point => point.remove());
            lines.forEach(line => line.remove());
            distanceLabels.forEach(label => label.remove());
            areaFills.forEach(fill => fill.remove());
            
            // Reset all arrays
            points = [];
            lines = [];
            distanceLabels = [];
            areaFills = [];
            isMeasuring = false;
            firstPoint = null;
            
            // Reset displays
            areaDisplay.textContent = "0";
            perimeterDisplay.textContent = "0";
            shapeTypeDisplay.textContent = "Not determined";
            
            // Reset buttons
            addPointBtn.disabled = false;
            addPointBtn.textContent = "Add Point";
            undoBtn.disabled = true;
            completeBtn.disabled = true;
            calculateBtn.disabled = true;
        }
        
        function createPoint(x, y) {
            const point = document.createElement('div');
            point.className = 'point';
            
            // Add point number
            const number = document.createElement('div');
            number.style.color = 'white';
            number.style.fontSize = '10px';
            number.style.textAlign = 'center';
            number.style.lineHeight = '12px';
            number.textContent = points.length + 1;
            point.appendChild(number);
            
            point.style.left = `${x}px`;
            point.style.top = `${y}px`;
            map.appendChild(point);
            return point;
        }
        
        function drawLine(startPoint, endPoint) {
            const startRect = startPoint.getBoundingClientRect();
            const endRect = endPoint.getBoundingClientRect();
            
            const x1 = startRect.left + startRect.width/2;
            const y1 = startRect.top + startRect.height/2;
            const x2 = endRect.left + endRect.width/2;
            const y2 = endRect.top + endRect.height/2;
            
            // Calculate line length and angle
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            // Create line element
            const line = document.createElement('div');
            line.className = 'line';
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;
            map.appendChild(line);
            lines.push(line);
            
            // Create distance label
            const label = document.createElement('div');
            label.className = 'distance-label';
            
            // Calculate position (midpoint of the line)
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            
            label.style.left = `${midX}px`;
            label.style.top = `${midY}px`;
            
            // Convert to meters (simplified)
            const distanceInMeters = (length / 100).toFixed(2);
            label.textContent = `${distanceInMeters}m`;
            
            map.appendChild(label);
            distanceLabels.push(label);
        }
    </script>
</body>
</html>